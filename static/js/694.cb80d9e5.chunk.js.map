{"version":3,"file":"static/js/694.cb80d9e5.chunk.js","mappings":"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","sources":["../node_modules/react-use-gesture/src/utils/math.ts","../node_modules/react-use-gesture/src/utils/rubberband.ts","../node_modules/react-use-gesture/src/utils/utils.ts","../node_modules/react-use-gesture/src/utils/resolveOptionsWith.ts","../node_modules/react-use-gesture/src/utils/event.ts","../node_modules/react-use-gesture/src/utils/config.ts","../node_modules/react-use-gesture/src/utils/state.ts","../node_modules/react-use-gesture/src/recognizers/Recognizer.ts","../node_modules/react-use-gesture/src/Controller.ts","../node_modules/react-use-gesture/src/hooks/useRecognizers.ts","../node_modules/react-use-gesture/src/recognizers/CoordinatesRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/DragRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/DistanceAngleRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/PinchRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/WheelRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/MoveRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/ScrollRecognizer.ts","../node_modules/react-use-gesture/src/hooks/useGesture.ts","../node_modules/react-use-gesture/src/hooks/buildConfig.ts","../node_modules/framer-motion/dist/es/render/dom/utils/resolve-element.mjs","../node_modules/framer-motion/dist/es/animation/GroupPlaybackControls.mjs","../node_modules/framer-motion/dist/es/animation/utils/create-visual-element.mjs","../node_modules/framer-motion/dist/es/animation/sequence/utils/calc-time.mjs","../node_modules/framer-motion/dist/es/utils/wrap.mjs","../node_modules/framer-motion/dist/es/easing/utils/get-easing-for-segment.mjs","../node_modules/framer-motion/dist/es/animation/sequence/utils/edit.mjs","../node_modules/framer-motion/dist/es/animation/sequence/utils/sort.mjs","../node_modules/framer-motion/dist/es/animation/sequence/create.mjs","../node_modules/framer-motion/dist/es/easing/utils/create-generator-easing.mjs","../node_modules/framer-motion/dist/es/animation/animate.mjs","../node_modules/framer-motion/dist/es/animation/utils/is-dom-keyframes.mjs","../node_modules/framer-motion/dist/es/value/use-motion-value.mjs"],"sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map(v => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map(v => beta * v)\n  const direction = delta.map(v => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n","function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n","export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n","export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n","import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && 'ontouchstart' in window\n}\n\nexport function supportsPointerEvents(): boolean {\n  return typeof window !== 'undefined' && 'onpointerdown' in window\n}\n\nfunction getEventTouches(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent) {\n  if ('pointerId' in event) return null\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches\n}\n\nexport function getTouchIds(event: TouchEvent | React.TouchEvent): number[] {\n  return Array.from(getEventTouches(event)!).map(t => t.identifier)\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(\n  event: TouchEvent | React.TouchEvent | React.PointerEvent | PointerEvent,\n  transform = identity\n): Vector2 {\n  const touchEvents = getEventTouches(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return transform([clientX, clientY])\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventValues(\n  event: React.TouchEvent | TouchEvent,\n  pointerIds: [number, number],\n  transform = identity\n) {\n  const [A, B] = Array.from(event.touches).filter(t => pointerIds.includes(t.identifier))\n\n  if (!A || !B) throw Error(`The event doesn't have two pointers matching the pointerIds`)\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  const distance = Math.hypot(dx, dy)\n  // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI\n  const values: Vector2 = transform([distance, angle])\n  const origin: Vector2 = transform([cx, cy])\n\n  return { values, origin }\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: React.UIEvent | UIEvent, transform = identity): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0])\n}\n\n// wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\nconst LINE_HEIGHT = 40\nconst PAGE_HEIGHT = 800\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: React.WheelEvent | WheelEvent, transform = identity): Vector2 {\n  let { deltaX, deltaY, deltaMode } = event\n  // normalize wheel values, especially for Firefox\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT\n    deltaY *= LINE_HEIGHT\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT\n    deltaY *= PAGE_HEIGHT\n  }\n  return transform([deltaX, deltaY])\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent, transform = identity): Vector2 {\n  return transform([event.scale, event.rotation])\n}\n","import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\nimport { supportsTouchEvents, supportsPointerEvents } from './event'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 50\nexport const DEFAULT_SWIPE_DURATION = 250\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n\n  transform: true,\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n  transform: true,\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  useTouch(value = false) {\n    const supportsTouch = supportsTouchEvents()\n    const supportsPointer = supportsPointerEvents()\n    if (value && supportsTouch) return true\n    if (supportsTouch && !supportsPointer) return true\n    return false\n  },\n  experimental_preventWindowScrollY(value = false) {\n    return value\n  },\n  threshold(\n    this: InternalDragOptions,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n  swipeDuration(value = DEFAULT_SWIPE_DURATION) {\n    return value\n  },\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState, PinchState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _threshold: [0, 0],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle & PinchState>({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {\n    this.controller = controller\n    this.args = args\n  }\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  get transform() {\n    return this.config.transform || this.controller.config.transform || identity\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T>\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { rubberband } = this.config\n\n    const {\n      _bounds,\n      _initial,\n      _active,\n      _intentional: wasIntentional,\n      lastOffset,\n      movement: prevMovement,\n      _threshold: _T,\n    } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : 0,\n      _intentional[1] !== false ? M[1] - _intentional[1] : 0,\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const touches = this.controller.pointerIds.size || this.controller.touchIds.size\n    const down = this.controller.state.shared.buttons > 0 || touches > 0\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n      locked: !!document.pointerLockElement,\n      touches,\n      down,\n    } as FullGestureState<T>\n\n    // @ts-expect-error\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  { state, config, stateKey, args, transform }: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T],\n  initial?: Vector2\n) {\n  const offset = state.offset\n  const startTime = event.timeStamp\n\n  const { initial: initialFn, bounds, threshold } = config\n\n  // the _threshold is the difference between a [0,0] offset converted to\n  // its new space coordinates\n  const _threshold = subV(transform(threshold), transform([0, 0])).map(Math.abs)\n\n  const _state = {\n    ...getInitialState()[stateKey],\n    _active: true,\n    args,\n    values,\n    initial: initial ?? values,\n    _threshold,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n\n  return { ..._state, _initial: valueFn(initialFn, _state), _bounds: valueFn(bounds, _state) }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { supportsTouchEvents, supportsGestureEvents, getTouchIds } from './utils/event'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  public pointerIds = new Set<number>() // register Pointer Events pointerIds\n  public touchIds = new Set<number>() // register Touch Events identifiers\n  public supportsTouchEvents = supportsTouchEvents()\n  public supportsGestureEvents = supportsGestureEvents()\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.classes = classes\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // // we also add event bindings for native handlers\n    for (let eventKey in this.nativeRefs) {\n      addBindings(bindings, eventKey, (event: any) => this.nativeRefs[eventKey]({ ...this.state.shared, event, args }))\n    }\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function addEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.add(event.pointerId)\n  } else {\n    controller.touchIds = new Set(getTouchIds(event))\n  }\n}\n\nexport function removeEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.delete(event.pointerId)\n  } else {\n    getTouchIds(event).forEach(id => controller.touchIds.delete(id))\n  }\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = [],\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), options)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  const controller = React.useMemo(() => new Controller(classes), [])\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  React.useEffect(controller.effect, [])\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into account)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners, addEventIds, removeEventIds } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nfunction persistEvent(event: React.PointerEvent | PointerEvent) {\n  'persist' in event && typeof event.persist === 'function' && event.persist()\n}\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  // TODO add back when setPointerCapture is widely wupported\n  // https://caniuse.com/#search=setPointerCapture\n  private setPointerCapture = (event: React.PointerEvent | PointerEvent) => {\n    // don't perform pointere capture when user wants to use touch events or\n    // when a pointerLockElement exists as this would throw an error\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { target, pointerId } = event\n    if (target && 'setPointerCapture' in target) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      // @ts-expect-error\n      target.setPointerCapture(pointerId)\n    }\n    this.updateGestureState({ _dragTarget: target, _dragPointerId: pointerId })\n  }\n\n  private releasePointerCapture = () => {\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { _dragTarget, _dragPointerId } = this.state\n    if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId))\n        try {\n          _dragTarget.releasePointerCapture(_dragPointerId)\n        } catch (e) {}\n    }\n  }\n\n  private preventScroll = (event: TouchEvent) => {\n    if (this.state._dragPreventScroll && event.cancelable) {\n      event.preventDefault()\n    }\n  }\n\n  private getEventId = (event: any): number => {\n    if (this.config.useTouch) return event.changedTouches[0].identifier\n    return event.pointerId\n  }\n\n  private isValidEvent = (event: any) => {\n    // if we were using pointer events only event.isPrimary === 1 would suffice\n    return this.state._pointerId === this.getEventId(event)\n  }\n\n  private shouldPreventWindowScrollY =\n    this.config.experimental_preventWindowScrollY && this.controller.supportsTouchEvents\n\n  private setUpWindowScrollDetection = (event: React.PointerEvent | PointerEvent) => {\n    persistEvent(event)\n    // we add window listeners that will prevent the scroll when the user has started dragging\n    updateWindowListeners(\n      this.controller,\n      this.stateKey,\n      [\n        ['touchmove', this.preventScroll],\n        ['touchend', this.clean.bind(this)],\n        ['touchcancel', this.clean.bind(this)],\n      ],\n      { passive: false }\n    )\n    this.setTimeout(this.startDrag.bind(this), 250, event)\n  }\n\n  private setUpDelayedDragTrigger = (event: React.PointerEvent | PointerEvent) => {\n    this.state._dragDelayed = true\n    persistEvent(event)\n    this.setTimeout(this.startDrag.bind(this), this.config.delay, event)\n  }\n\n  private setStartState = (event: React.PointerEvent | PointerEvent) => {\n    const values = getPointerEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: this.getEventId(event), // setting pointerId locks the gesture to this specific event\n    })\n\n    this.updateGestureState(this.getMovement(values))\n  }\n\n  onDragStart = (event: React.PointerEvent | PointerEvent): void => {\n    addEventIds(this.controller, event)\n    if (!this.enabled || this.state._active) return\n\n    this.setStartState(event)\n    this.setPointerCapture(event as PointerEvent)\n\n    if (this.shouldPreventWindowScrollY) this.setUpWindowScrollDetection(event)\n    else if (this.config.delay > 0) this.setUpDelayedDragTrigger(event)\n    else this.startDrag(event, true) // we pass the values to the startDrag event\n  }\n\n  startDrag(event: React.PointerEvent | PointerEvent, onDragIsStart: boolean = false) {\n    // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n    if (\n      // if the gesture isn't active (probably means)\n      !this.state._active ||\n      // if the drag has already started we should ignore subsequent attempts\n      this.state._dragStarted\n    )\n      return\n\n    if (!onDragIsStart) this.setStartState(event)\n    this.updateGestureState({ _dragStarted: true, _dragPreventScroll: true, cancel: this.onCancel })\n    this.clearTimeout()\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    if (\n      // if the gesture was canceled or\n      this.state.canceled ||\n      // if onDragStart wasn't fired or\n      !this.state._active ||\n      // if the event pointerId doesn't match the one that initiated the drag\n      !this.isValidEvent(event) ||\n      // if the event has the same timestamp as the previous event\n      // note that checking type equality is ONLY for tests ¯\\_(ツ)_/¯\n      (this.state._lastEventType === event.type && event.timeStamp === this.state.timeStamp)\n    )\n      return\n\n    let values\n\n    if (document.pointerLockElement) {\n      const { movementX, movementY } = event\n      values = addV(this.transform([movementX, movementY]), this.state.values)\n    } else values = getPointerEventValues(event, this.transform)\n\n    const kinematics = this.getKinematics(values, event)\n\n    // if startDrag hasn't fired\n    if (!this.state._dragStarted) {\n      // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n      if (this.state._dragDelayed) {\n        this.startDrag(event)\n        return\n      }\n      // if the user wants to prevent vertical window scroll when user starts dragging\n      if (this.shouldPreventWindowScrollY) {\n        if (!this.state._dragPreventScroll && kinematics.axis) {\n          // if the user is dragging horizontally then we should allow the drag\n          if (kinematics.axis === 'x') {\n            this.startDrag(event)\n          } else {\n            this.state._active = false\n            return\n          }\n        } else return\n      } else return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    const realDistance = calculateDistance(kinematics._movement!)\n    let { _dragIsTap } = this.state\n    if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _dragIsTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    removeEventIds(this.controller, event)\n\n    // if the event pointerId doesn't match the one that initiated the drag\n    // we don't want to end the drag\n    if (!this.isValidEvent(event)) return\n    this.clean()\n\n    // if the gesture is no longer active (ie canceled)\n    // don't do anything\n    if (!this.state._active) return\n    this.state._active = false\n\n    const tap = this.state._dragIsTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n    const sd = this.config.swipeDuration\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < sd) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateSharedState({ buttons: 0 })\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(this.config.filterTaps && tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._dragStarted = false\n    this.releasePointerCapture()\n    clearWindowListeners(this.controller, this.stateKey)\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true, _active: false })\n    this.updateSharedState({ buttons: 0 })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n\n  onClick = (event: React.UIEvent | UIEvent): void => {\n    if (!this.state._dragIsTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart)\n      addBindings(bindings, 'onTouchMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd)\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd)\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart)\n      addBindings(bindings, 'onPointerMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onPointerUp', this.onDragEnd)\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n    }\n\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  protected getInternalMovement(values: [number, number?], state: GestureState<T>): Vector2 {\n    const prev_a = state.values[1]\n    // not be defined if ctrl+wheel is used for zoom only\n    let [d, a = prev_a] = values\n\n    let delta_a = a - prev_a\n    let next_turns = state.turns\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a)\n    return subV([d, a - 360 * next_turns], state.initial)\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    const turns = (values[1] - state._movement![1] - this.state.initial[1]) / 360\n    const dt = event.timeStamp - this.state.timeStamp!\n    const { distance, velocity, ...kinematics } = calculateAllKinematics(state.movement!, state.delta!, dt)\n    return { turns, ...state, ...kinematics }\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { da: state.values, vdva: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n\n/**\n * @param dangle is a small change of variable on \"lifting\" of the circle.\n * It's expected to be small and cannot be greater than 270 or under -270\n */\nexport function fixContinuity(dangle: number) {\n  dangle -= Math.round(dangle / 360) * 360\n  if (dangle > 270) return dangle - 360\n  if (dangle < -270) return dangle + 360\n  return dangle\n}\n","import DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { Vector2, WebKitGestureEvent } from '../types'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventValues,\n  getWheelEventValues,\n  getWebkitGestureEventValues,\n  getTouchIds,\n} from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, addEventIds, removeEventIds } from '../Controller'\n\nconst ZOOM_CONSTANT = 7\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\nexport class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  readonly ingKey = 'pinching'\n  readonly stateKey = 'pinch'\n\n  onPinchStart = (event: React.TouchEvent | TouchEvent) => {\n    addEventIds(this.controller, event)\n    const touchIds = this.controller.touchIds\n\n    if (!this.enabled) return\n\n    if (this.state._active) {\n      // check that the pointerIds that initiated the gesture\n      // are still enabled. This is useful for when the page\n      // loses track of the pointers (minifying gesture on iPad).\n      if (this.state._pointerIds.every(id => touchIds.has(id))) return\n      // something was wrong with the pointers but we let it go.\n    }\n    // until we reach two fingers on the target don't react\n    if (touchIds.size < 2) return\n    const _pointerIds = Array.from(touchIds).slice(0, 2) as [number, number]\n\n    const { values, origin } = getTwoTouchesEventValues(event, _pointerIds, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerIds,\n      cancel: this.onCancel,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: React.TouchEvent | TouchEvent): void => {\n    const { canceled, _active } = this.state\n    if (\n      canceled ||\n      !_active ||\n      // if the event has the same timestamp as the previous event\n      event.timeStamp === this.state.timeStamp\n    )\n      return\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    try {\n      const { values, origin } = getTwoTouchesEventValues(event, this.state._pointerIds, this.transform)\n      const kinematics = this.getKinematics(values, event)\n\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...kinematics,\n        origin,\n      })\n\n      this.fireGestureHandler()\n    } catch (e) {\n      this.onPinchEnd(event)\n    }\n  }\n\n  onPinchEnd = (event: React.TouchEvent | TouchEvent): void => {\n    removeEventIds(this.controller, event)\n    const pointerIds = getTouchIds(event)\n\n    // if none of the lifted pointerIds is in the state pointerIds don't do anything\n    if (this.state._pointerIds.every(id => !pointerIds.includes(id))) return\n\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ _active: false, canceled: true })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const values = getWebkitGestureEventValues(event, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    // this normalizes the values of the Safari's WebKitEvent by calculating\n    // the delta and then multiplying it by a constant.\n    const values = getWebkitGestureEventValues(event, this.transform)\n    values[0] =\n      (values[0] - (this.state.event as WebKitGestureEvent).scale) * WEBKIT_DISTANCE_SCALE_FACTOR + this.state.values[0]\n\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n    this.fireGestureHandler()\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: React.WheelEvent | WheelEvent) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: React.WheelEvent | WheelEvent) => {\n    const [, delta_d] = getWheelEventValues(event, this.transform)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    // ZOOM_CONSTANT is based on Safari trackpad natural zooming\n    const _delta_d = -delta_d * ZOOM_CONSTANT\n    // new distance is the previous state distance added to the delta\n    const d = prev_d + _delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [_delta_d, a] as Vector2,\n    }\n  }\n\n  onWheel = (event: React.WheelEvent | WheelEvent): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: React.WheelEvent | WheelEvent): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (event.cancelable) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event, this.state.values),\n      ...getGenericPayload(this, event, true),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.cancelable) event.preventDefault()\n\n    this.updateSharedState(getGenericEventData(event))\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (\n      this.controller.config.domTarget &&\n      !this.controller.supportsTouchEvents &&\n      this.controller.supportsGestureEvents\n    ) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart)\n      addBindings(bindings, 'onGestureChange', this.onGestureChange)\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd)\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart)\n      addBindings(bindings, 'onTouchMove', this.onPinchChange)\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd)\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd)\n      addBindings(bindings, 'onWheel', this.onWheel)\n    }\n  }\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  readonly ingKey = 'wheeling'\n  readonly stateKey = 'wheel'\n  debounced = true\n\n  handleEvent = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return\n    if (!this.enabled) return\n\n    this.setTimeout(this.onEnd)\n    this.updateSharedState(getGenericEventData(event))\n\n    const values = addV(getWheelEventValues(event, this.transform), this.state.values)\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movement = this.getMovement(values)\n      const geometry = calculateAllGeometry(movement.delta!)\n\n      this.updateGestureState(movement)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const movement = this.getMovement(this.state.values)\n    this.updateGestureState(movement)\n    this.updateGestureState({ _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onWheel', this.handleEvent)\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  readonly ingKey = 'moving'\n  readonly stateKey = 'move'\n\n  debounced = true\n\n  onMove = (event: React.PointerEvent | PointerEvent): void => {\n    if (!this.enabled) return\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const values = this.state.values\n    this.updateGestureState(this.getMovement(values))\n    this.updateGestureState({ velocities: [0, 0], velocity: 0, _active: false })\n    this.fireGestureHandler()\n  }\n\n  hoverTransform = () => {\n    return this.controller.config.hover!.transform || this.controller.config.transform\n  }\n\n  onPointerEnter = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const values = getPointerEventValues(event, this.hoverTransform())\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...getGenericPayload(this, event, true),\n        args: this.args,\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n    if (!this.controller.config.hover!.enabled) return\n\n    const values = getPointerEventValues(event, this.hoverTransform())\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...getGenericPayload(this, event),\n      args: this.args,\n      values,\n      active: false,\n    }\n\n    this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n  }\n\n  addBindings(bindings: any): void {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove)\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter)\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave)\n    }\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  readonly ingKey = 'scrolling'\n  readonly stateKey = 'scroll'\n  debounced = true\n\n  handleEvent = (event: React.UIEvent | UIEvent): void => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const values = getScrollEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movementDetection = this.getMovement(values)\n      const geometry = calculateAllGeometry(movementDetection.delta!)\n\n      this.updateGestureState(movementDetection)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.updateGestureState({ ...this.getMovement(this.state.values), _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onScroll', this.handleEvent)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport { buildComplexConfig } from './buildConfig'\nimport {\n  InternalConfig,\n  InternalHandlers,\n  UserHandlers,\n  UseGestureConfig,\n  Handlers,\n  EventTypes,\n  AnyGestureEventTypes,\n} from '../types'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\n\nexport function wrapStart(fn: Function) {\n  return function (this: any, { first }: any) {\n    if (first) fn.apply(this, arguments)\n  }\n}\n\nexport function wrapEnd(fn: Function) {\n  return function (this: any, { last }: any) {\n    if (last) fn.apply(this, arguments)\n  }\n}\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\n\nfunction sortHandlers(handlers: object) {\n  const native: any = {}\n  const handle: any = {}\n  const actions = new Set()\n\n  for (let key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch)\n      handle[key] = (handlers as any)[key]\n    } else {\n      native[key] = (handlers as any)[key]\n    }\n  }\n\n  return [handle, native, actions]\n}\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<T extends AnyGestureEventTypes = EventTypes>(\n  _handlers: Handlers<T>,\n  config: UseGestureConfig = {}\n) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(_handlers)\n\n  RecognizersMap.set('drag', DragRecognizer)\n  RecognizersMap.set('hover', MoveRecognizer)\n  RecognizersMap.set('move', MoveRecognizer)\n  RecognizersMap.set('pinch', PinchRecognizer)\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  RecognizersMap.set('wheel', WheelRecognizer)\n\n  const mergedConfig: InternalConfig = buildComplexConfig(config, actions)\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag')\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel')\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll')\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove')\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch')\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover\n\n  return useRecognizers<UseGestureConfig>(internalHandlers, mergedConfig, nativeHandlers)\n}\n\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\nfunction includeStartEndHandlers(handlers: Partial<UserHandlers>, handlerKey: HandlerKey) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n","import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, transform, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({\n    domTarget,\n    eventOptions,\n    transform,\n    window,\n    enabled,\n  })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n","import { invariant } from '../../../utils/errors.mjs';\n\nfunction resolveElements(elements, scope, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        let root = document;\n        if (scope) {\n            invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n            root = scope.current;\n        }\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = root.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nexport { resolveElements };\n","class GroupPlaybackControls {\n    constructor(animations) {\n        this.animations = animations.filter(Boolean);\n    }\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    stop() {\n        this.runAll(\"stop\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\nexport { GroupPlaybackControls };\n","import { isSVGElement } from '../../render/dom/utils/is-svg-element.mjs';\nimport { SVGVisualElement } from '../../render/svg/SVGVisualElement.mjs';\nimport { HTMLVisualElement } from '../../render/html/HTMLVisualElement.mjs';\nimport { visualElementStore } from '../../render/store.mjs';\n\nfunction createVisualElement(element) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {},\n            },\n            latestValues: {},\n        },\n    };\n    const node = isSVGElement(element)\n        ? new SVGVisualElement(options, {\n            enableHardwareAcceleration: false,\n        })\n        : new HTMLVisualElement(options, {\n            enableHardwareAcceleration: true,\n        });\n    node.mount(element);\n    visualElementStore.set(element, node);\n}\n\nexport { createVisualElement };\n","/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nfunction calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (typeof next === \"number\") {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\n\nexport { calcNextTime };\n","const wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nexport { wrap };\n","import { wrap } from '../../utils/wrap.mjs';\nimport { isEasingArray } from './is-easing-array.mjs';\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nexport { getEasingForSegment };\n","import { getEasingForSegment } from '../../../easing/utils/get-easing-for-segment.mjs';\nimport { removeItem } from '../../../utils/array.mjs';\nimport { mix } from '../../../utils/mix.mjs';\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mix(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nexport { addKeyframes, eraseKeyframes };\n","function compareByTime(a, b) {\n    if (a.at === b.at) {\n        if (a.value === null)\n            return 1;\n        if (b.value === null)\n            return -1;\n        return 0;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nexport { compareByTime };\n","import { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numElements)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            if (numKeyframes <= 2 && type === \"spring\") {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            const targetTime = startTime + duration;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            /**\n             * Find all the elements specified in the definition and parse value\n             * keyframes from their timeline definitions.\n             */\n            const elements = resolveElements(subject, scope, elementCache);\n            const numElements = elements.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const element = elements[elementIndex];\n                const subjectSequence = getSubjectSequence(element, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n                }\n            }\n            prevTime = currentTime;\n            currentTime += maxDuration;\n        }\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition[key]\n        ? { ...transition, ...transition[key] }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n","import { spring } from '../../animation/generators/spring/index.mjs';\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../../animation/generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds } from '../../utils/time-conversion.mjs';\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100) {\n    const generator = spring({ keyframes: [0, scale], ...options });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => generator.next(duration * progress).value / scale,\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\nexport { createGeneratorEasing };\n","import { resolveElements } from '../render/dom/utils/resolve-element.mjs';\nimport { visualElementStore } from '../render/store.mjs';\nimport { invariant } from '../utils/errors.mjs';\nimport { GroupPlaybackControls } from './GroupPlaybackControls.mjs';\nimport { isDOMKeyframes } from './utils/is-dom-keyframes.mjs';\nimport { animateTarget } from './interfaces/visual-element-target.mjs';\nimport { createVisualElement } from './utils/create-visual-element.mjs';\nimport { animateSingleValue } from './interfaces/single-value.mjs';\nimport { createAnimationsFromSequence } from './sequence/create.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    invariant(Boolean(numElements), \"No valid element provided.\");\n    const animations = [];\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        /**\n         * Check each element for an associated VisualElement. If none exists,\n         * we need to create one.\n         */\n        if (!visualElementStore.has(element)) {\n            /**\n             * TODO: We only need render-specific parts of the VisualElement.\n             * With some additional work the size of the animate() function\n             * could be reduced significantly.\n             */\n            createVisualElement(element);\n        }\n        const visualElement = visualElementStore.get(element);\n        const transition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof transition.delay === \"function\") {\n            transition.delay = transition.delay(i, numElements);\n        }\n        animations.push(...animateTarget(visualElement, { ...keyframes, transition }, {}));\n    }\n    return new GroupPlaybackControls(animations);\n}\nconst isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);\nfunction animateSequence(sequence, options, scope) {\n    const animations = [];\n    const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\n        let animation;\n        if (isMotionValue(subject)) {\n            animation = animateSingleValue(subject, keyframes.default, transition.default);\n        }\n        else {\n            animation = animateElements(subject, keyframes, transition);\n        }\n        animations.push(animation);\n    });\n    return new GroupPlaybackControls(animations);\n}\nconst createScopedAnimate = (scope) => {\n    /**\n     * Implementation\n     */\n    function scopedAnimate(valueOrElementOrSequence, keyframes, options) {\n        let animation;\n        if (isSequence(valueOrElementOrSequence)) {\n            animation = animateSequence(valueOrElementOrSequence, keyframes, scope);\n        }\n        else if (isDOMKeyframes(keyframes)) {\n            animation = animateElements(valueOrElementOrSequence, keyframes, options, scope);\n        }\n        else {\n            animation = animateSingleValue(valueOrElementOrSequence, keyframes, options);\n        }\n        if (scope) {\n            scope.animations.push(animation);\n        }\n        return animation;\n    }\n    return scopedAnimate;\n};\nconst animate = createScopedAnimate();\n\nexport { animate, createScopedAnimate };\n","function isDOMKeyframes(keyframes) {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\n\nexport { isDOMKeyframes };\n","import { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n"],"names":["addV","v1","v2","map","v","i","subV","calculateDistance","movement","Math","hypot","apply","calculateAllGeometry","delta","dl","alpha","direction","distance","calculateAllKinematics","dt","beta","velocity","velocities","sign","x","Number","rubberband","dimension","constant","abs","Infinity","pow","rubberband2","rubberbandIfOutOfBounds","position","min","max","value","minMax","noop","chainFns","fns","Array","_len","_key","arguments","length","result","_step","_iterator","_createForOfIteratorHelperLoose","done","this","ensureVector","fallback","undefined","Error","isArray","assignDefault","Object","assign","valueFn","_len2","args","_key2","resolveWith","config","resolvers","_i","_Object$entries","entries","_Object$entries$_i","key","resolver","call","supportsTouchEvents","window","getEventTouches","event","type","changedTouches","targetTouches","getTouchIds","from","t","identifier","getGenericEventData","buttons","shiftKey","altKey","metaKey","ctrlKey","identity","xy","getPointerEventValues","transform","touchEvents","_ref","clientX","clientY","getTwoTouchesEventValues","pointerIds","touches","filter","includes","A","_Array$from$filter","B","dx","dy","cx","cy","values","atan2","PI","origin","LINE_HEIGHT","PAGE_HEIGHT","getWheelEventValues","deltaX","deltaY","deltaMode","getWebkitGestureEventValues","scale","rotation","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","_extends","axis","lockDirection","bounds","state","left","_value2$left","right","_value2$right","top","_value2$top","bottom","_value2$bottom","isBrowser","document","createElement","InternalGenericOptionsNormalizers","domTarget","_window","_x","toString","eventOptions","_temp","passive","_ref$passive","capture","_ref$capture","InternalDistanceAngleOptionsNormalizers","_value","_ref2","distanceBounds","_ref2$distanceBounds","angleBounds","_ref2$angleBounds","_distanceBounds","D","_angleBounds","InternalDragOptionsNormalizers","useTouch","supportsTouch","supportsPointer","experimental_preventWindowScrollY","_k","_ref3","filterTaps","_ref3$filterTaps","_ref3$lockDirection","_ref3$axis","swipeVelocity","swipeDistance","swipeDuration","delay","getInternalGenericOptions","getInternalCoordinatesOptions","getInternalDistanceAngleOptions","getInternalDragOptions","getInitial","mixed","_active","_blocked","_intentional","_movement","_initial","_bounds","_threshold","_lastEventType","_dragStarted","_dragPreventScroll","_dragIsTap","_dragDelayed","intentional","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","down","locked","drag","_pointerId","vxvy","tap","swipe","pinch","_pointerIds","da","vdva","turns","wheel","move","scroll","RecognizersMap","Map","identity$1","Recognizer","controller","debounced","setTimeout","callback","ms","clearTimeout","_this","timeouts","stateKey","concat","fireGestureHandler","forceFlag","clean","prev_active","next_active","ingKey","size","touchIds","mapStateValues","pointerLockElement","newMemo","handler","updateSharedState","sharedState","updateGestureState","gestureState","checkIntentionality","getMovement","_this$state","wasIntentional","prevMovement","_T","M","getInternalMovement","i0","getIntentionalDisplacement","i1","intentionalityCheck","_rubberband","computeRubberband","handlers","Vx","Vy","Rx","Ry","X1","_bounds$","X2","Y1","_bounds$2","Y2","getGenericPayload","isStartEvent","getStartGestureState","_ref4","initialFn","_state","Controller","classes","Set","supportsGestureEvents","GestureEvent","e","bind","bindings","RecognizerClass","addBindings","eventKey","nativeRefs","_loop","domListeners","getDomTargetFromConfig","removeListeners","takeAll","name","slice","toLowerCase","push","addListeners","updateDomListeners","props","captureString","_i2","_Object$entries2","_Object$entries2$_i","fnsArray","getPropsListener","effect","forEach","el","_controller$config","windowListeners","clearAllWindowListeners","addEventIds","add","pointerId","removeEventIds","id","array","splice","_ref5","current","fn","listeners","options","_step2","_iterator2","_step2$value","eventName","eventHandler","addEventListener","_step3","_iterator3","_step3$value","removeEventListener","useRecognizers","nativeHandlers","internalHandlers","get","hover","resolveClasses","React","deprecationNoticeForDomTarget","process","CoordinatesRecognizer","_Recognizer","absX","_movement$map","absY","getKinematics","persistEvent","persist","DragRecognizer","_CoordinatesRecognize","setPointerCapture","target","_dragTarget","_dragPointerId","releasePointerCapture","hasPointerCapture","preventScroll","cancelable","preventDefault","getEventId","isValidEvent","shouldPreventWindowScrollY","setUpWindowScrollDetection","updateWindowListeners","_assertThisInitialized","startDrag","setUpDelayedDragTrigger","setStartState","onDragStart","onDragChange","movementX","movementY","kinematics","genericEventData","genericPayload","realDistance","onDragEnd","vx","_this$state$velocitie","vy","mx","_this$state$movement","my","ix","_this$state$_intentio","iy","svx","_this$config$swipeVel","svy","sx","_this$config$swipeDis","sy","sd","endState","prototype","clearWindowListeners","onCancel","onClick","stopPropagation","_inheritsLoose","_proto","onDragIsStart","DistanceAngleRecognizer","prev_a","d","a","_values$","delta_a","next_turns","_objectWithoutPropertiesLoose","PinchRecognizer","_DistanceAngleRecogni","onPinchStart","every","has","_getTwoTouchesEventVa","onPinchChange","_getTwoTouchesEventVa2","onPinchEnd","onGestureStart","onGestureChange","_this$state2","onGestureEnd","wheelShouldRun","getWheelValuesFromEvent","delta_d","prev_d","_this$state$values","_delta_d","onWheel","onWheelEnd","onWheelChange","onWheelStart","_this$getWheelValuesF","_this$getWheelValuesF2","WheelRecognizer","handleEvent","onEnd","geometry","MoveRecognizer","onMove","onMoveEnd","onMoveChange","onMoveStart","hoverTransform","onPointerEnter","onPointerLeave","ScrollRecognizer","currentTarget","scrollX","_event$currentTarget","scrollY","scrollLeft","scrollTop","getScrollEventValues","movementDetection","RE_NOT_NATIVE","useGesture","_handlers","_native","handle","actions","test","RegExp","lastMatch","sortHandlers","_sortHandlers","set","mergedConfig","_config","buildComplexConfig","includeStartEndHandlers","onHover","handlerKey","startKey","endKey","resolveElements","elements","scope","selectorCache","_a","root","invariant","Boolean","querySelectorAll","Element","GroupPlaybackControls","animations","_classCallCheck","_createClass","onResolve","onReject","Promise","all","then","catch","propName","newValue","getAll","time","setAll","speed","duration","methodName","controls","runAll","createVisualElement","element","presenceContext","visualState","renderState","transformOrigin","style","vars","attrs","latestValues","node","isSVGElement","SVGVisualElement","enableHardwareAcceleration","HTMLVisualElement","mount","visualElementStore","calcNextTime","next","prev","labels","startsWith","parseFloat","wrap","rangeSize","getEasingForSegment","easing","isEasingArray","addKeyframes","sequence","keyframes","endTime","keyframe","at","removeItem","eraseKeyframes","mix","compareByTime","b","defaultSegmentEasing","createAnimationsFromSequence","_ref$defaultTransitio","defaultTransition","sequenceTransition","_objectWithoutProperties","_excluded","defaultDuration","animationDefinitions","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","segment","_segment","_slicedToArray","subject","_segment$","transition","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numElements","valueKeyframesAsList","keyframesAsList","_valueTransition$dela","_valueTransition$time","times","defaultOffset","_valueTransition$type","remainingTransition","_excluded2","_valueTransition$ease","ease","calculatedDelay","numKeyframes","absoluteDelta","isNumberKeyframesArray","springTransition","_objectSpread","secondsToMilliseconds","springEasing","generator","spring","calcGeneratorDuration","maxGeneratorDuration","progress","millisecondsToSeconds","createGeneratorEasing","targetTime","remainder","fillOffset","unshift","isMotionValue","getValueSequence","getSubjectSequence","subjectSequence","getValueTransition","valueSequences","sort","valueOffset","valueEasing","_valueSequence$_i","definition","isNumber","animateElements","elementOrSelector","visualElement","_toConsumableArray","animateTarget","animate","valueOrElementOrSequence","animation","animateSingleValue","default","animateSequence","isDOMKeyframes","useMotionValue","useConstant","motionValue","useContext","MotionConfigContext","isStatic","_useState","useState","setLatest","useEffect","on"],"sourceRoot":""}